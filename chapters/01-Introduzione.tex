\documentclass[main.tex]{subfiles}

\begin{document}
\sloppy


\vspace{1.0cm}

\section{Introduzione}\label{sec:Intro}
Nel mondo dell'eventistica progettare e programmare in anticipo e virtualmente palchi e show è una pratica sempre più diffusa e viene realizzata attraverso programmi detti \say{Previsualizer}. Solitamente vengono utilizzati software\cite{capture} ad-hoc closed-source e molto costosi, con una resa qualitativa molto elevata. Esistono anche dei software gratuiti, molto spesso già inclusi nei sistemi di controllo luci, sempre closed-source, che però omettono molte funzionalità essenziali ed hanno una resa grafica nettamente inferiore.\newline

Lo scopo del progetto CPGDTF-Importer è quello di realizzare un Previsualizer open-source basato su \say{Unreal Engine}\cite{UnrealEngine}, un importante ed affermato software ed engine grafico per la realizzazione di videogiochi, sviluppato dalla \say{Epic Games}. Unreal Engine (da ora abbreviato con \say{UE}) è gratuito e open-source, ha un rendering visivo fotorealistico e mette a disposizione un sistema di plugin con i quali è possibile integrare l'importazione di file non nativi, automatizzare i processi di creazione di \say{oggetti} utilizzabili all'interno dell'engine, oppure definire il comportamento di questi oggetti stessi. UE dispone di una libreria di plugin sviluppati dalla Epic Games tra cui figura \say{DMXEngine}, che già implementa protocolli standard per la gestione di luci e già detta delle basi per sviluppare un proprio plugin nel medesimo contesto.  
\newline
CPGDTF-Importer è, in particolare, un plugin per l'\say{editor} di UE, ovvero quella sezione che permette la creazione di mondi che, nel nostro caso, consisterebbero in palcoscenici virtuali. Il plugin lavorerà principalmente su 3 livelli:
\begin{itemize}
    \item Importazione di luci (chiamate anche \say{fixture}) da un formato standard (GDTF \cite{GDTF}, spiegato nella sezione \ref{subsec:1_gdtf}), negli \say{Actor} di UE
    \item Importazione di luci sottoforma di Attori all'interno di mondi e gestione delle loro impostazioni
    \item Simulazione in real-time del comportamento delle fixture il più possibile vicino alla realtà
\end{itemize}

\subsection{Anatomia di una fixture}\label{subsec:1_fixtureAnatomy}
I fari (Che chiameremo anche \say{luci} o \say{fixture}) utilizzati nel mondo dell'eventistica sono dei macchinari di vario tipo e dimensioni che hanno il compito di generare luce di forme e colori differenti. Le fixture che ci interessano sono quelle utilizzate sia come illuminazione di oggetti (Ad esempio, le luci frontali che illuminano un attore in teatro) che come effettistica (Ovvero le luci che fanno effetti aereografici ai concerti). Storicamente le luci nascono come semplici fari monocolore a cui si potevano applicare a mano dei filtri davanti la sorgente luminosa ed a cui si poteva solamente regolare l'intensità attraverso apparecchiature chiamate \say{dimmer}. Solo a partire dagli anni '90 sono entrate in commercio le prime fixture intelligenti, ovvero con la possibilità di essere controllate da remoto attraverso una console luci sfruttando il protocollo DMX \cite{DMX}. 

\subsubsection{Luci statiche e dinamiche}\label{subsec:1_1_fixtureTypes}
Le fixture possono essere classificabili come statiche o dinamiche. Le fixture dette \say{statiche} sono fixture che sono formate da un unico \say{blocco} (Che GDTF chiama \say{geometrie}, mentre Unreal Engine chiama \say{SceneComponents}) e che, fisicamente, non si muovono. Sono quelle più semplici nonché il primo tipo di faro entrato in commercio.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\linewidth]{img/introduzione/staticFixtureExample.jpg}
    \caption{Esempio di fixture statica}
    \label{fig:staticFixture}
\end{figure}
Le fixture dette invece \say{dinamiche} (chiamate anche \say{Teste mobili}) sono composte da più geometrie collegate tra loro da motori, in modo che quella responsabile di emettere il fascio di luce possa roteare, di solito su due assi. Solitamente la geometria che viene poggiata per terra o appesa viene chiamata \say{base}, quella che emette luce \say{testa}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{img/introduzione/dynamicFixtureAnatomy.jpg}
    \caption{Geometrie di un faro dinamico}
    \label{fig:DynamicFixture}
\end{figure}

\subsubsection{Moduli di una luce}\label{subsec:1_1_modules}
All'interno della testa, così come all'interno delle fixture statiche, è presente una sorgente luminosa che può essere sia bianca se il faro utilizza una sintesi colore sottrattiva, che colorata se il faro utilizza una sintesi colore additiva. La luce viene fatta passare attraverso vari moduli che ne alterano il colore, la messa a fuoco e la forma fino ad uscire dalla lente principale collocata ad una estremità della testa. Su praticamente tutti i fari in commercio non è possibile montare moduli custom o invertirli con quelli di un altro faro. Ciò ci permette di avere un unico file per descrivere interamente il comportamento di un determinato faro. \newline
I moduli che verranno toccati in questo progetto sono i seguenti:
\begin{itemize}
    \item \textbf{Ruote colori e gobo}: Sono delle ruote in cui sopra sono presenti su degli slot, dei filtri colori o delle forme. Hanno sempre uno slot libero in cui la luce può passare senza essere modificata e, girando, possono mettere in mezzo alla luce uno slot alla volta
    \item \textbf{Sintesi e correzione dei colori}: Nelle luci a sintesi additiva troviamo LED di colori differenti (RGB + Bianco, Ambra, Lime, UV, etc); nelle luci a sintesi sottrattiva invece abbiamo una luce bianca e delle flag CMY che vengono inserite davanti per regolarne il colore. Esistono anche dei filtri (sempre sottrattivi) per effettuare una sorta di color correction.
    \item \textbf{Sagomatore}: È un sistema composto da quattro lame che possono essere inserite nel fascio di luce da direzioni differenti e possono essere inclinate, in modo da ritagliare in maniera precisa triangoli e quadrilateri precisi per fare puntamenti.
    \item \textbf{Iris}: Sono delle lame circolari che entrano nel fascio di luce da tutte le direzioni e si occupano di ridurne la dimensione. Il funzionamento è analogo al diaframma di una fotocamera
    \item \textbf{Frost}: È un filtro atto a rendere soffusa la luce, smorzando i bordi di eventuali figure che si stanno proiettando
\end{itemize}
I moduli solitamente funzionano sottrattivamente: per ogni modulo a partire dalla fonte luminosa, andiamo ad occluderla mano a mano per disegnare la forma che vogliamo ottenere.
% TODO FOTO E SCHEMA DEI MODULI IN UNA LUCE APERTA

\subsubsection{Protocollo DMX}\label{subsec:1_1_dmx}
Oggi giorno, quasi tutte le fixture che vengono usate sono intelligenti e, come citato sopra, vengono controllate via DMX. DMX è un protocollo unidirezionale in cui un master (solitamente una console luci) invia 44 volte al secondo agli slave (le varie fixture) un array di 512 byte chiamato \say{Universo DMX}. Le luci hanno memorizzato un offset all'interno di questo array chiamato \say{Indirizzo DMX} che viene impostato manualmente su ognuna dall'operaio che le monta su un palcoscenico. Ogni volta che arriva un nuovo pacchetto DMX la luce inizierà a leggere la sua sezione di dati a partire dall'indirizzo/offset specificato. Ogni byte che legge è chiamato \say{canale} e, solitamente, corrisponde al valore da assegnare ad una diversa funzionalità della luce.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.65\linewidth]{img/introduzione/dmxChannelDescExample.png}
    \caption{Esempio di canali DMX. Se il canale 1 di questa luce viene portato a FULL (255), la luce si colorerà di azzurro. Se, invece, il canale 6 viene impostato al valore 50, si colorerà di rosa.}
    \label{fig:dmxChannelsExample}
\end{figure}

Alcune fixture possono supportare più modalità di controllo, che possono andare ad attivare o disattivare funzionalità della luce stessa, oppure possono permettere il controllo più preciso di alcune funzionalità; introducendo quindi nuovi canali da controllare o riordinando quelli già esistenti. 


\subsection{GDTF}\label{subsec:1_gdtf}
GDTF - \textit{General Device Type Format} - è un formato per descrivere fixture nella maniera più accurata possibile. È stato sviluppato da MAlighting (azienda produttrice del sistema di controllo luci attualmente più usato in show medio-grandi), Robe (Uno dei leader industriali nello sviluppo e realizzazione di luci per l'eventistica) e Vectorworks (Un software di CAD/Deisgn anch'esso molto usato nella progettazione e previsualizzazione di palcoscenici). 
\newline

Un file GDTF è essenzialmente un pacchetto contenente all'interno i modelli delle varie geometrie che compongono un faro, le texture delle sue gobo/animazioni/prismi/etc ed un file in formato XML contentente una descrizione esaustiva delle caratteristiche del faro. \newline
Dei vari dati contenuti in questo XML a noi ci interessano principalmente:
\begin{itemize}
    \item Informazioni e texture sulle ruote colori e gobo
    \item Informazioni sui valori di fade e accelerazione per l'interpolazione delle varie componenti fisiche
    \item Modelli 3D, geometrie di un faro e come sono in relazione tra di loro
    \item Informazioni sui vari canali DMX e varie modalità DMX
\end{itemize}

\subsubsection{Ruote}\label{subsec:1_2_wheels}
Nel nodo \lstinline{Wheels} all'interno del file XML viene definita una lista di ruote presenti all'interno del faro. Ogni ruota (rappresentata da un nodo \lstinline{Wheel}) può avere un nome, e dentro ciascuna troviamo una lista di \lstinline{Slot} che rappresentano ognuno un elemento della ruota. Ogni slot ha anch'esso un nome, e può avere degli attributi opzionali quali:
\begin{itemize}
    \item \lstinline{Color}: Il colore di uno slot presente su una color wheel.
    \item \lstinline{MediaFileName}: Nome del file PNG contenente la texture di questo slot, utilizzato per le ruote gobo ed animazione.
\end{itemize}
I prismi vengono comunque classificati come ruote, dove ogni slot rappresenta un tipo diverso di prisma. In questi casi avranno come figli dei nodi \lstinline{Facet} rappresentanti le facce di un prisma, in cui ne viene definito il colore, la rotazione, la traslazione e la grandezza della faccia.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{img/introduzione/GDTFwheelExample.jpg}
    \caption{Nodo \lstinline{Wheels} in un file GDTF}
    \label{fig:dmxChannelsExample}
\end{figure}

\subsubsection{Geometrie}\label{subsec:1_2_geometries}
Il nodo \lstinline{Models} viene utilizzato per definire una lista di modelli da importare. Per ciascuno può essere assegnato un nome e delle dimensioni per effettuare dello scaling al modello stesso. 

I vari modelli che vengono importati vengono poi usati all'interno del nodo \lstinline{Geometries}, che va a definire una gerarchia di geometrie, specificando i punti di interconnessione tra le varie e gli assi e centri di rotazione di ciascuna. Alcune geometrie, come ad esempio \lstinline{Beam}, sono particolari, perché rappresentano un punto in cui la luce può essere emessa dalla fixture.

Le varie funzionalità di una fixture sono implementate all'interno di una particolare geometria, o meglio, \textit{riguardano} una geometria.

\subsubsection{Modalità e canali DMX}\label{subsec:1_2_dmxchannels}

\subsection{Informazioni sul tirocinio}\label{subsec:1_tirocinio}
CPGDTF-Importer è un progetto sviluppato dalla \say{Clay Paky}, azienda italiana leader mondiale nella progettazione e realizzazione di luci per concerti, architettura e teatri, per cui ho svolto il tirocinio curriculare. Lo sviluppo ha avuto inizio nel Maggio 2022 da un altro tirocinante che ha forkato il plugin originale sviluppato dalla Epic Games ed ha iniziato ad aggiungere funzioni che, nonostante fossero basilari, mancavano totalmente. Il plugin originale leggeva solamente quali fossero i componenti di una fixture, i suoi canali e poche altre informazioni. Utilizzava sempre modelli 3D e ruote gobo predefinite, non importava i valori di fade e accellerazione per l'interpolazione, mancavano moltissime funzionalità delle fixture e quelle esistenti funzionavano male, e molto altro ancora. Il tirocinante precedente, dopo aver speso quasi tutto il periodo del suo tirocinio a fare ricerca su come funzionasse il plugin originale ha gettato delle basi per iniziare ad estenderlo e per completare l'importazione di tutti i dati e file da un GDTF, ha scritto delle documentazioni abbastanza esaustive, per poi andare via.\newline

Al mio arrivo in Claypaky mi è stato affidato il progetto con l'obiettivo di finire di implementare nuove funzionalità delle fixtures in modo da poter arrivare a simulare completamente tutti i fari dell'azienda.

Dopo aver speso un primo periodo a prendere conoscenza con la codebase mi sono reso conto di quanto buona parte del codice necessitasse di un refactoring. In particolare ho riscontrato difficoltà nell'implementare nuove features, sia perché il codice che si occupava del rendering dell'illuminazione non fosse in alcun modo modulare e sia perché la gerarchia di classi che le gestisce fosse maldisegnata e con tanto codice duplicato. 

Solamente dopo aver risolto questi grossi problemi strutturali nel codice (e dopo aver fatto funzionare correttamente l'interpolazione) ho potuto dedicarmi all'implementazione effettiva di nuove features. 

%\subsection{Strutture dati su Unreal Engine}\label{subsec:1_dataStructsUE}

\subsection{Struttura della tesi}\label{subsec:1_thesisInfo}
L'elaborato è articolato come segue. Ogni capitolo rappresenta una milestone del progetto:
\begin{itemize}
    \item \textbf{Capitolo \ref{sec:Intro}, Introduzione} %We like recurion
    \item \textbf{Capitolo \ref{sec:RenderingPipeline}, design di una pipeline di rendering}: In questo capitolo verrà analizzata l'implementazione originale con la quale veniva effettuato il rendering dell'illuminazione di ogni singola fixture. Verranno evidenziati i problemi e mostrate idee per risolverli. Infine verrà anche esposta l'implementazione per la generazione di una pipeline vera e propria per il rendering dei vari moduli di una luce. 
    \item \textbf{Capitolo \ref{sec:FixtureComponentHierachy}, redesign gerarchia dei FixtureComponent}: Tratta l'analisi della gerarchia precedente dei FixtureComponent, ovvero quelle classi responsabili di controllare ogni singola feature che compone una fixture. Vengono proposte nuove idee di implementazione e mostrati quali dati e metodi servirebbe mettere a disposizione alle classi che implementano la singola feature.
    \item \textbf{Capitolo \ref{sec:Interpolation}, reimplementazione dell'interpolazione}: All'interno di questo capitolo vengono velocemente esposti i problemi dell'attuale classe che controlla l'interpolazione, ovvero il controllo del movimento dei motori virtuali. Successivamente viene mostrata la nuova implementazione della classe, esponendo i vari problemi che si sono verificati durante la scrittura del codice e come sono stati risolti.
    \item \textbf{Capitolo \ref{sec:NewFeatures}, implementazione di nuove funzionalità alle fixtures}: Una volta sistemata la struttura del plugin e reso comodo e meno error-prone l'implementazione di nuove feature, qui viene descritta come sono state pensate e implementate le due funzionalità che sono state aggiunte a CPGDTF-Importer.
    \item \textbf{Capitolo \ref{sec:End}, conclusioni}: In questo capitolo conclusivo, vengono sintetizzati i problemi, generali, emersi durante lo sviluppo con GDTF ed Unreal Engine. Inoltre, vengono valutati futuri sviluppi con Arri (l'azienda che ha acquisito Claypaky lo scorso Marzo, durante il mio periodo di tirocinio) e con Epic Games stessa.
\end{itemize}


\end{document}