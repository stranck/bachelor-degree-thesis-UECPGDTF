\documentclass[main.tex]{subfiles}

\begin{document}
\sloppy


\vspace{1.0cm}

\section{Implementazione di nuove funzionalità alle fixtures}\label{sec:NewFeatures}
Una volta creata una pipeline di rendering, sistemata la gerarchia dei componenti e fatta funzionare l'interpolazione è possibile finalmente aggiungere nuove features alle fixture virtuali. Come visto nel capitolo \ref{sec:RenderingPipeline}, per aggiungere una nuova feature bisogna:
\begin{itemize}
	\item Implementarla come codice HLSL
	\item Implementarla come MaterialFunction
	\item Aggiungerla al generatore di codice HLSL
	\item Aggiungerla al generatore della pipeline per il rendering del materiale Light e Lens
\end{itemize}
In questo capitolo non tratteremo mai il secondo punto poiché rappresenta la trasposizione in MaterialExpression del codice già visto in HLSL.

\subsection{Sagomatori}\label{subsec:5_shaper}
Il sistema dei sagomatori (detto anche \say{framing system} oppure \say{shaper}) consiste in un modulo composto da 4 lame (dette anche \say{bandiere}) che possono immettersi ed inclinasi singolarmente all'interno del fascio di luce. Inoltre, l'intero modulo può roteare, muovendo contemporaneamente la direzione in cui si immettono tutte le lame si immettono.
%TODO Esempi con foto
Il controllo della lama può avvenie in due modi:
\begin{itemize}
	\item \textbf{A+B}: Controlliamo singolarmente l'immissione dei due punti estremi della lama ($A$ e $B$). Per avere la lama \say{dritta} Dovremmo avere $A = B$, per inclinarla da un lato basta avere uno dei due valori maggiori dell'altro.
	%TODO Schema immagine
	\item \textbf{A+Rot}: Controlliamo l'immissione della lama ($A$) e separatamente la sua inclinazione ($R$).
	%TODO Schema immagine
\end{itemize}
Effettuare il rendering di una funzionalità come lo shaper attraverso texture è davvero oneroso in termini computazionali. La scelta migliore è fare il rendering immaginandoci il framing system come delle equazioni matematiche. In generale, il rendering di un material avviene effettuando il rendering di varie coordinate UV, ovvero coordinate bidimensionali normalizzate tra [0, 1]. Possiamo immaginare il nostro codice come se fosse inserito in un ciclo for che si scorre \say{tutte} le x e le y comprese tra 0 ed 1. Il nostro codice però si occupa di renderizzare una sola UV alla volta. 

Se immaginiamo quindi una singola lama come una equazione matematica, possiamo renderizzarla controllando semplicemente se la Y della coordinata UV che stiamo renderizzando in quel momento (TODO mettere x o y) si trova sopra o sotto l'equazione. Il nostro lavoro diventa quindi generare la corretta equazione matematica in base agli input $A$ e $B$ o $R$.
%TODO Wrapfigure in cui mostriamo un semplice rendering `return y > 0.5;'

Per trovare l'equazione della retta quando facciamo il sample A+B, possiamo ricorrere alla formula per ottenre l'equazione di una retta passante per due punti:
\[m = \frac{y_2 - y_1}{x_2 - x_1}\]
Immaginiamo che i valori di $A$ e $B$ corrispondano alle loro y, che $A$ si trovi a coordinate $x = 0$ e che $B$ si trovi a $x = 1$. La formula sarà uguale a
\[m = \frac{y_B - y_A}{x_B - x_A} = \frac{B - A}{1 - 0} = B - A\]
In questo modo generiamo il coefficiente una retta che però ha sempre origine in $(0, 0)$. Nella realtà, ciò che abbiamo appena creato è una bandiare in cui solamente il valore B \say{funziona}. Per far \say{funzionare} anche il valore $A$, basta aggiungerlo come termine noto del'equazione. Come scritto sopra, per generare una flag bisogna controllare quando stiamo \say{sopra} questa equazione, rendendola quindi uguale a:
\[y > x(B - A) + A\]

%TODO Sample a+rot

Come anche le ruote, anche il framing system deve implementare il frost. Piuttosto di applicare un filtro di blur al framing system già renderizzato, è preferibile in termini di peso computazionale,  

%TODO spiegazione ricalcolo valore A in base a frost

%TODO spiegazione rotazione

\subsection{Iris}\label{subsec:5_Iris}

\end{document}